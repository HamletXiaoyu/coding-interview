# 题目

原文：

Given a circular linked list, implement an algorithm which returns node at the beginning of the loop.

DEFINITION

Circular linked list: A (corrupt) linked list in which a node’s next pointer points to an earlier node, so as to make a loop in the linked list.

EXAMPLE

Input: A -> B -> C -> D -> E -> C [the same C as earlier]

Output: C

译文：

给定一个循环链表，实现一个算法返回这个环的开始结点。

定义：

循环链表：链表中一个结点的指针指向先前已经出现的结点，导致链表中出现环。

例子：

输入：A -> B -> C -> D -> E -> C [结点C在之前已经出现过]

输出：结点C



# 解答

设环的开始结点(图中的D)前有k个结点，环有n个结点(上图中n从D到K共8个结点)。 快指针fast和慢指针slow一开始都指向头结点head，它们移动k步可到环的开始结点。 假设慢指针走过m个结点后，快指针追上了它，这时快指针走过了2m个结点。 快指针比慢指针多走过的结点都在环里转圈了，是环中结点数n的整数倍，即：

```
2m - m = pn --> m = pn, p为正整数

```

如果头结点是第一个结点的话，那么相遇结点就是第m+1=pn+1个结点(慢指针走了m步)。 当环开始结点为起点1时，相遇结点为第pn+1-k个结点(减去前k个结点)。这pn+1-k 有可能是绕环转了很多圈后的一个数，假设继续走过一些结点，它就绕环刚好q圈， 则从相遇结点需要再经过 qn-(pn+1-k)+1=(q-p)n+k个结点，才能回到环的开始结点(图中结点D)。 由于从相遇结点走回到环的开始结点(图中D)所需要步数一定是小于等于一圈的，因此有

```
(q-p)n+k <= n 

```

由于q，p，n，k都是正整数，因此有q-p <= 0，否则上式左边大于右边。 因为q-p <= 0，可以得出上式左边是小于等于k的。即：

```
(q-p)n+k <= k

```

如果让快指针在相遇结点继续走，不过这次把速度变成了慢指针一样， 那么它要走(q-p)n+k步到达环开始结点，让慢指针从头结点head开始走， 它要走k步到达环开始结点。最后，它们将在环开始结点处相遇。

这个是怎么得出来的呢？假设快指针走了(q-p)n+k个结点到达环的开始结点，这时， 慢指针也走了(q-p)n+k步，它离环的开始结点还有

```
k - [ (q-p)n + k ] = (p-q)n (步)

```

从上面我们知道q-p <= 0，因此p-q >= 0。 这说明慢指针离环开始结点的步数正好是环中结点数的整数倍， 所以当慢指针到达环的开始结点时， 快指针(此时它的速度也是1)刚好在环中转了(p-q)圈，然后和慢指针在环的开始结点处相遇。